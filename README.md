# MSP430 joystick Project

The original purpose of this project was to reverse engineer one of my computer joysticks in order to reuse the stick 
portion for [the plow](https://github.com/RobbyChapman/plow-bot). The platform for the stick consists of 1 main MCU, 
1 daughter board for the right platform buttons, and one for the MLX90333 hall effect sensor. In my case, I only want 
the stick and hall effect sensor.

![Alt text](./assets/joy1.JPG?raw=true "Packet Format")

To get started, I dissembled the joystick and started tracing back from the 20 pin breakout on the main MCU. This 
breakout predominately consist of toggle switches and hat switches, which reside on the stick itself. These are important
as they will be reused for control of the plow-bots peripherals, for example, triggering actuator to raise.lower the 
plow, or toggling remote switches for lights etc. Below is the resulting map of traces:

    Yellow:     Front trigger
    Red:        Thumb trigger
    Brown:      Left top button
    Green:      Right top button
    Blue:       Top D-pad left
    Purple:     Top D-pad down
    Gray:       Top D-pad right
    White:      Top D-pad up

![Alt text](./assets/joy2.JPG?raw=true "Packet Format")

The next step was to find which pins communicate with the MLX90333. For this task, I had to break out the scope and 
logic analyzer. The datasheet clearly defines the pinout, so it was mainly just a matter of tracing the wires from the
daughter board back to the main MCU. To do this, I soldered a few jumpers coming off the main MCU for the probes. The
resulting map for it's SPI bus looks like this(From left to right):

    Yellow:     SCK
    Blue:       SS
    red:        MOSI/MISO
    Brown:      GND
    Black:      VDD

![Alt text](./assets/joy3.JPG?raw=true "Packet Format")

The final step in isolating the joystick from the platform was to swap out the main MCU for my MSP430. This is where the
bulk of the work is. 

### GPIO
We have 8 buttons, and 1 hall effect sensor. The 8 buttons were re routed to the MSP as GPIO inputs. Interrupts were 
then registered for each signal. A simple continuity check was used to determine which pin services which switch.

### SPI
In terms of the MLX90333, the goal was to mimic the signals generated by the original MCU. To do this, I first captured 
a baseline conversation with the logic analyzer. Analysis of the resulting capture providing the timing and polarity of 
the clock. For this joystick, the clock is active hi, idle low, with captures on even clock changes for sampling the 
trailing edge of each phase. The is represented by the timing diagram below:

![Alt text](./assets/mlx90333_timing.JPG?raw=true "Packet Format")

Where:
![Alt text](./assets/mlx90333_timing2.JPG?raw=true "Packet Format")


This chip is interesting in the sense that it leverages a single pin for MISO/MOSI data transfer, ultimately 
making this a half duplex device as seen below: 

![Alt text](./assets/mlx90333_frame.JPG?raw=true "Packet Format")

This poses a few challenges for the MSP430. Basically you have to ensure whatever bytes you're shifting out, do not 
overwrite the bytes that are being shifted in, as they are share the same pin, synchronizes by the same clock. I started
solving this in software, but took a step back after a few hours as it felt like a force fit. I needed some way of 
controlling the flow of data, without eating up clock cycles toggling modes. After a bit of research, I opted to solve 
this in hardware, by adding diodes for MISO/MOSI. This way, data can come in from MISO without corrupting data going out
on MOSI and vise versa. The resulting frame generation on the MSP430 now looks like this:

![Alt text](./assets/msp430_capture.JPG?raw=true "Packet Format")


### Packet Format
The contract for each frame takes the following format:

![Alt text](./assets/mlx90333_packet.JPG?raw=true "Packet Format")

Where the LSB is the CRC of the 6 byte X-Y-Z sum.